// Generated by psc version 0.9.3
"use strict";
var Prelude = require("../Prelude");
var Test_StrongCheck_Arbitrary = require("../Test.StrongCheck.Arbitrary");
var Data_Functor = require("../Data.Functor");
var Data_Eq = require("../Data.Eq");
var Data_Ord = require("../Data.Ord");
var Data_Semiring = require("../Data.Semiring");
var Data_Ring = require("../Data.Ring");
var Data_CommutativeRing = require("../Data.CommutativeRing");
var Data_EuclideanRing = require("../Data.EuclideanRing");
var Data_Field = require("../Data.Field");
var Test_StrongCheck_Gen = require("../Test.StrongCheck.Gen");
var Control_Monad_Free = require("../Control.Monad.Free");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra");
var ApproxNumber = function (x) {
    return x;
};
var semiringApproxNumber = new Data_Semiring.Semiring(function (v) {
    return function (v1) {
        return v + v1;
    };
}, function (v) {
    return function (v1) {
        return v * v1;
    };
}, 1, 0);
var ringApproxNumber = new Data_Ring.Ring(function () {
    return semiringApproxNumber;
}, function (v) {
    return function (v1) {
        return v - v1;
    };
});
var commutativeRingApproxNumber = new Data_CommutativeRing.CommutativeRing(function () {
    return ringApproxNumber;
});
var euclideanRingApproxNumber = new Data_EuclideanRing.EuclideanRing(function () {
    return commutativeRingApproxNumber;
}, function (v) {
    return Data_EuclideanRing.degree(Data_EuclideanRing.euclideanRingNumber)(v);
}, function (v) {
    return function (v1) {
        return v / v1;
    };
}, function (v) {
    return function (v1) {
        return Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingNumber)(v)(v1);
    };
});
var fieldApproxNumber = new Data_Field.Field(function () {
    return euclideanRingApproxNumber;
});
var coarbitraryApproxNumber = new Test_StrongCheck_Arbitrary.Coarbitrary(function (v) {
    return Test_StrongCheck_Arbitrary.coarbitrary(Test_StrongCheck_Arbitrary.coarbNumber)(v);
});
var arbitraryApproxNumber = new Test_StrongCheck_Arbitrary.Arbitrary(Data_Functor.map(Test_StrongCheck_Gen.functorGenT(Control_Monad_Free.freeMonad))(ApproxNumber)(Test_StrongCheck_Arbitrary.arbitrary(Test_StrongCheck_Arbitrary.arbNumber)));
var approximateEqual = function (x) {
    return function (y) {
        return y - x <= 1.0e-8 && y - x >= -1.0e-8;
    };
};
var eqApproxNumber = new Data_Eq.Eq(function (v) {
    return function (v1) {
        return approximateEqual(v)(v1);
    };
});
var ordApproxNumber = new Data_Ord.Ord(function () {
    return eqApproxNumber;
}, function (v) {
    return function (v1) {
        return Data_Ord.compare(Data_Ord.ordNumber)(v)(v1);
    };
});
module.exports = {
    ApproxNumber: ApproxNumber, 
    approximateEqual: approximateEqual, 
    arbitraryApproxNumber: arbitraryApproxNumber, 
    coarbitraryApproxNumber: coarbitraryApproxNumber, 
    eqApproxNumber: eqApproxNumber, 
    ordApproxNumber: ordApproxNumber, 
    semiringApproxNumber: semiringApproxNumber, 
    ringApproxNumber: ringApproxNumber, 
    commutativeRingApproxNumber: commutativeRingApproxNumber, 
    euclideanRingApproxNumber: euclideanRingApproxNumber, 
    fieldApproxNumber: fieldApproxNumber
};

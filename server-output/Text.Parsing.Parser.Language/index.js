// Generated by psc version 0.9.3
"use strict";
var Prelude = require("../Prelude");
var Control_Alt = require("../Control.Alt");
var Text_Parsing_Parser = require("../Text.Parsing.Parser");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String");
var Text_Parsing_Parser_Token = require("../Text.Parsing.Parser.Token");
var Data_Identity = require("../Data.Identity");
var Data_Semigroup = require("../Data.Semigroup");
var emptyDef = (function () {
    var op$prime = function (dictMonad) {
        return Text_Parsing_Parser_String.oneOf(dictMonad)([ ":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~" ]);
    };
    return {
        commentStart: "", 
        commentEnd: "", 
        commentLine: "", 
        nestedComments: true, 
        identStart: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("_")), 
        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ])), 
        opStart: op$prime(Data_Identity.monadIdentity), 
        opLetter: op$prime(Data_Identity.monadIdentity), 
        reservedOpNames: [  ], 
        reservedNames: [  ], 
        caseSensitive: true
    };
})();
var haskellStyle = (function () {
    var op$prime = function (dictMonad) {
        return Text_Parsing_Parser_String.oneOf(dictMonad)([ ":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~" ]);
    };
    var $4 = Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef);
    var $2 = {};
    for (var $3 in $4) {
        if ($4.hasOwnProperty($3)) {
            $2[$3] = $4[$3];
        };
    };
    $2.commentStart = "{-";
    $2.commentEnd = "-}";
    $2.commentLine = "--";
    $2.nestedComments = true;
    $2.identStart = Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity);
    $2.identLetter = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ]));
    $2.opStart = op$prime(Data_Identity.monadIdentity);
    $2.opLetter = op$prime(Data_Identity.monadIdentity);
    $2.reservedOpNames = [  ];
    $2.reservedNames = [  ];
    $2.caseSensitive = true;
    return $2;
})();
var haskell98Def = (function () {
    var $7 = Text_Parsing_Parser_Token.unGenLanguageDef(haskellStyle);
    var $5 = {};
    for (var $6 in $7) {
        if ($7.hasOwnProperty($6)) {
            $5[$6] = $7[$6];
        };
    };
    $5.reservedOpNames = [ "::", "..", "=", "\\", "|", "<-", "->", "@", "~", "=>" ];
    $5.reservedNames = [ "let", "in", "case", "of", "if", "then", "else", "data", "type", "class", "default", "deriving", "do", "import", "infix", "infixl", "infixr", "instance", "module", "newtype", "where", "primitive" ];
    return $5;
})();
var haskellDef = (function () {
    var $9 = {};
    for (var $10 in haskell98Def) {
        if (haskell98Def.hasOwnProperty($10)) {
            $9[$10] = haskell98Def[$10];
        };
    };
    $9.identLetter = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(haskell98Def.identLetter)(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("#"));
    $9.reservedNames = Data_Semigroup.append(Data_Semigroup.semigroupArray)(haskell98Def.reservedNames)([ "foreign", "import", "export", "primitive", "_ccall_", "_casm_", "forall" ]);
    return $9;
})();
var haskell = Text_Parsing_Parser_Token.makeTokenParser(Data_Identity.monadIdentity)(haskellDef);
var javaStyle = (function () {
    var $14 = Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef);
    var $12 = {};
    for (var $13 in $14) {
        if ($14.hasOwnProperty($13)) {
            $12[$13] = $14[$13];
        };
    };
    $12.commentStart = "/*";
    $12.commentEnd = "*/";
    $12.commentLine = "//";
    $12.nestedComments = true;
    $12.identStart = Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity);
    $12.identLetter = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ]));
    $12.reservedNames = [  ];
    $12.reservedOpNames = [  ];
    $12.caseSensitive = false;
    return $12;
})();
module.exports = {
    emptyDef: emptyDef, 
    haskell: haskell, 
    haskellDef: haskellDef, 
    haskellStyle: haskellStyle, 
    javaStyle: javaStyle
};

// Generated by psc version 0.9.3
"use strict";
var Prelude = require("../Prelude");
var Control_MonadPlus = require("../Control.MonadPlus");
var Control_Monad_Rec_Class = require("../Control.Monad.Rec.Class");
var Control_Plus = require("../Control.Plus");
var Data_Bifunctor = require("../Data.Bifunctor");
var Data_Either = require("../Data.Either");
var Data_Show = require("../Data.Show");
var Data_Eq = require("../Data.Eq");
var Data_Functor = require("../Data.Functor");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Control_Apply = require("../Control.Apply");
var Control_Bind = require("../Control.Bind");
var Control_Applicative = require("../Control.Applicative");
var Control_Alt = require("../Control.Alt");
var Data_Boolean = require("../Data.Boolean");
var Control_Alternative = require("../Control.Alternative");
var Control_Monad = require("../Control.Monad");
var Control_MonadZero = require("../Control.MonadZero");
var ParseError = (function () {
    function ParseError(value0) {
        this.value0 = value0;
    };
    ParseError.create = function (value0) {
        return new ParseError(value0);
    };
    return ParseError;
})();
var Parser = (function () {
    function Parser(value0) {
        this.value0 = value0;
    };
    Parser.create = function (value0) {
        return new Parser(value0);
    };
    return Parser;
})();
var unParser = function (v) {
    return v.value0;
};
var $$try = function (v) {
    return new Parser(function (v1) {
        return Data_Bifunctor.lmap(Data_Either.bifunctorEither)(function (v2) {
            var $26 = {};
            for (var $27 in v2) {
                if (v2.hasOwnProperty($27)) {
                    $26[$27] = v2[$27];
                };
            };
            $26.pos = v1.pos;
            return $26;
        })(v.value0(v1));
    });
};
var showParseError = new Data_Show.Show(function (v) {
    return v.value0;
});
var runParser = function (v) {
    return function (s) {
        return Data_Bifunctor.bimap(Data_Either.bifunctorEither)(function (v1) {
            return v1.error;
        })(function (v1) {
            return v1.result;
        })(v.value0({
            str: s, 
            pos: 0
        }));
    };
};
var functorParser = new Data_Functor.Functor(function (f) {
    return function (v) {
        return new Parser(function ($79) {
            return Data_Functor.map(Data_Either.functorEither)(function (v1) {
                return {
                    result: f(v1.result), 
                    suffix: v1.suffix
                };
            })(v.value0($79));
        });
    };
});
var fail = function (msg) {
    return new Parser(function (v) {
        return new Data_Either.Left({
            pos: v.pos, 
            error: new ParseError(msg)
        });
    });
};
var eqParseError = new Data_Eq.Eq(function (v) {
    return function (v1) {
        return v.value0 === v1.value0;
    };
});
var applyParser = new Control_Apply.Apply(function () {
    return functorParser;
}, function (v) {
    return function (v1) {
        return new Parser(function (s) {
            return Control_Bind.bind(Data_Either.bindEither)(v.value0(s))(function (v2) {
                return Control_Bind.bind(Data_Either.bindEither)(v1.value0(v2.suffix))(function (v3) {
                    return Control_Applicative.pure(Data_Either.applicativeEither)({
                        result: v2.result(v3.result), 
                        suffix: v3.suffix
                    });
                });
            });
        });
    };
});
var bindParser = new Control_Bind.Bind(function () {
    return applyParser;
}, function (v) {
    return function (f) {
        return new Parser(function (s) {
            return Control_Bind.bind(Data_Either.bindEither)(v.value0(s))(function (v1) {
                return unParser(f(v1.result))(v1.suffix);
            });
        });
    };
});
var applicativeParser = new Control_Applicative.Applicative(function () {
    return applyParser;
}, function (a) {
    return new Parser(function (s) {
        return new Data_Either.Right({
            result: a, 
            suffix: s
        });
    });
});
var monadParser = new Control_Monad.Monad(function () {
    return applicativeParser;
}, function () {
    return bindParser;
});
var monadRecParser = new Control_Monad_Rec_Class.MonadRec(function () {
    return monadParser;
}, function (f) {
    return function (a) {
        var split = function (v) {
            if (v.result instanceof Data_Either.Left) {
                return new Data_Either.Left({
                    state: v.result.value0, 
                    str: v.suffix
                });
            };
            if (v.result instanceof Data_Either.Right) {
                return new Data_Either.Right({
                    result: v.result.value0, 
                    suffix: v.suffix
                });
            };
            throw new Error("Failed pattern match at Text.Parsing.StringParser line 84, column 7 - line 84, column 70: " + [ v.constructor.name ]);
        };
        return new Parser(function (str) {
            return Control_Monad_Rec_Class.tailRecM(Control_Monad_Rec_Class.monadRecEither)(function (st) {
                return Data_Functor.map(Data_Either.functorEither)(split)(unParser(f(st.state))(st.str));
            })({
                state: a, 
                str: str
            });
        });
    };
});
var altParser = new Control_Alt.Alt(function () {
    return functorParser;
}, function (v) {
    return function (v1) {
        return new Parser(function (s) {
            var $73 = v.value0(s);
            if ($73 instanceof Data_Either.Left) {
                if (s.pos === $73.value0.pos) {
                    return v1.value0(s);
                };
                if (Data_Boolean.otherwise) {
                    return new Data_Either.Left({
                        error: $73.value0.error, 
                        pos: $73.value0.pos
                    });
                };
            };
            return $73;
        });
    };
});
var plusParser = new Control_Plus.Plus(function () {
    return altParser;
}, fail("No alternative"));
var alternativeParser = new Control_Alternative.Alternative(function () {
    return applicativeParser;
}, function () {
    return plusParser;
});
var monadZeroParser = new Control_MonadZero.MonadZero(function () {
    return alternativeParser;
}, function () {
    return monadParser;
});
var monadPlusParser = new Control_MonadPlus.MonadPlus(function () {
    return monadZeroParser;
});
module.exports = {
    ParseError: ParseError, 
    Parser: Parser, 
    fail: fail, 
    runParser: runParser, 
    "try": $$try, 
    unParser: unParser, 
    showParseError: showParseError, 
    eqParseError: eqParseError, 
    functorParser: functorParser, 
    applyParser: applyParser, 
    applicativeParser: applicativeParser, 
    altParser: altParser, 
    plusParser: plusParser, 
    alternativeParser: alternativeParser, 
    bindParser: bindParser, 
    monadParser: monadParser, 
    monadZeroParser: monadZeroParser, 
    monadPlusParser: monadPlusParser, 
    monadRecParser: monadRecParser
};
